"""Manage the CGP auto-patcher VS Code workspace extension."""

from __future__ import annotations

import glob
import json
import os
import shutil
import sys
import textwrap
from pathlib import Path
from typing import Optional

from . import __version__

EXTENSION_NAME = "cgp-auto-patcher"
GITHUB_REPO = "baaaaaaaka/cursor_gui_patch"


def _extensions_root(target: str) -> Path:
    """Return the Cursor extensions root directory for *target* ('gui' or 'server')."""
    if target == "server":
        return Path.home() / ".cursor-server" / "extensions"
    # gui (default)
    if sys.platform == "darwin":
        return Path.home() / ".cursor" / "extensions"
    if sys.platform == "win32":
        return Path(os.environ.get("USERPROFILE", "~")) / ".cursor" / "extensions"
    return Path.home() / ".cursor" / "extensions"


def _ext_dir_name(version: str) -> str:
    return f"{EXTENSION_NAME}-{version}"


def _find_existing(extensions_root: Path) -> list[Path]:
    """Find all existing cgp-auto-patcher-* directories under *extensions_root*."""
    pattern = str(extensions_root / f"{EXTENSION_NAME}-*")
    return sorted(Path(p) for p in glob.glob(pattern) if Path(p).is_dir())


def _generate_package_json(version: str) -> str:
    return json.dumps(
        {
            "name": EXTENSION_NAME,
            "displayName": "CGP Auto Patcher",
            "description": "Auto re-apply cursor-gui-patch after Cursor updates",
            "version": version,
            "publisher": "cgp",
            "engines": {"vscode": "^1.80.0"},
            "extensionKind": ["workspace"],
            "activationEvents": ["onStartupFinished"],
            "main": "./extension.js",
        },
        indent=2,
    )


def _generate_extension_js() -> str:
    return textwrap.dedent("""\
        // CGP Auto Patcher – generated by cursor-gui-patch
        // This extension ensures cgp is available and runs `cgp patch` on activation.
        const vscode = require('vscode');
        const { execFile, exec } = require('child_process');
        const https = require('https');
        const fs = require('fs');
        const path = require('path');
        const os = require('os');
        const zlib = require('zlib');

        const REPO = '""" + GITHUB_REPO + """';

        // ── activate ──────────────────────────────────────
        async function activate(context) {
            try {
                const cgp = await ensureCgp();
                if (cgp) await runPatch(cgp);
            } catch (_) { /* never throw into Cursor */ }
        }

        // ── ensureCgp ─────────────────────────────────────
        async function ensureCgp() {
            // 1. Check PATH
            const found = await which('cgp');
            if (found) return found;

            // 2. Check well-known location
            const home = os.homedir();
            const knownBin = process.platform === 'win32'
                ? path.join(process.env.LOCALAPPDATA || path.join(home, 'AppData', 'Local'), 'cgp', 'cgp.exe')
                : path.join(home, '.local', 'bin', 'cgp');

            if (fs.existsSync(knownBin)) return knownBin;

            // 3. Download from GitHub
            return await downloadLatest();
        }

        // ── downloadLatest ────────────────────────────────
        async function downloadLatest() {
            const apiUrl = `https://api.github.com/repos/${REPO}/releases/latest`;
            const releaseJson = await httpsGet(apiUrl);
            const release = JSON.parse(releaseJson.toString('utf8'));
            const tag = release.tag_name;
            if (!tag) return null;

            const assetName = selectAsset(process.platform, process.arch);
            if (!assetName) return null;

            const downloadUrl = `https://github.com/${REPO}/releases/download/${tag}/${assetName}`;
            const data = await httpsGet(downloadUrl);

            const home = os.homedir();
            const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cgp-'));

            try {
                const archivePath = path.join(tmpDir, assetName);
                fs.writeFileSync(archivePath, data);

                // Extract
                if (assetName.endsWith('.tar.gz')) {
                    await execPromise(`tar xzf "${archivePath}"`, { cwd: tmpDir });
                } else if (assetName.endsWith('.zip')) {
                    if (process.platform === 'win32') {
                        await execPromise(
                            `powershell -NoProfile -Command "Expand-Archive -Path '${archivePath}' -DestinationPath '${tmpDir}' -Force"`,
                            { cwd: tmpDir }
                        );
                    } else {
                        await execPromise(`unzip -o "${archivePath}"`, { cwd: tmpDir });
                    }
                } else {
                    return null;
                }

                // Install to versioned directory
                const installRoot = process.platform === 'win32'
                    ? path.join(process.env.LOCALAPPDATA || path.join(home, 'AppData', 'Local'), 'cgp')
                    : path.join(home, '.local', 'lib', 'cgp');
                const binDir = process.platform === 'win32'
                    ? installRoot
                    : path.join(home, '.local', 'bin');
                const versionsDir = path.join(installRoot, 'versions');
                const versionDir = path.join(versionsDir, tag);

                fs.mkdirSync(versionsDir, { recursive: true });
                fs.mkdirSync(binDir, { recursive: true });

                // Remove old version dir if exists
                if (fs.existsSync(versionDir)) {
                    fs.rmSync(versionDir, { recursive: true, force: true });
                }

                // Move extracted cgp/ folder to version dir
                const extractedCgp = path.join(tmpDir, 'cgp');
                fs.renameSync(extractedCgp, versionDir);

                const exeName = process.platform === 'win32' ? 'cgp.exe' : 'cgp';
                const exePath = path.join(versionDir, exeName);

                // Make executable on Unix
                if (process.platform !== 'win32') {
                    try { fs.chmodSync(exePath, 0o755); } catch (_) {}
                }

                // Create current symlink
                const currentLink = path.join(installRoot, 'current');
                try { fs.unlinkSync(currentLink); } catch (_) {}
                try { fs.symlinkSync(versionDir, currentLink); } catch (_) {}

                // Create bin symlink
                const binLink = path.join(binDir, exeName);
                try { fs.unlinkSync(binLink); } catch (_) {}
                try { fs.symlinkSync(exePath, binLink); } catch (_) {}

                return binLink;
            } finally {
                try { fs.rmSync(tmpDir, { recursive: true, force: true }); } catch (_) {}
            }
        }

        // ── runPatch ──────────────────────────────────────
        async function runPatch(cgpPath) {
            return new Promise((resolve) => {
                execFile(cgpPath, ['patch'], { timeout: 60000 }, (err, stdout, stderr) => {
                    if (err) { resolve(); return; }
                    const output = (stdout || '').toString();
                    const m = output.match(/Patched:\\s*(\\d+)/);
                    if (m && parseInt(m[1], 10) > 0) {
                        vscode.window.showInformationMessage(
                            `CGP: Patched ${m[1]} file(s). Reload to apply.`,
                            'Reload'
                        ).then(choice => {
                            if (choice === 'Reload') {
                                vscode.commands.executeCommand('workbench.action.reloadWindow');
                            }
                        });
                    }
                    resolve();
                });
            });
        }

        // ── helpers ───────────────────────────────────────
        function httpsGet(url, redirects) {
            if (redirects === undefined) redirects = 5;
            return new Promise((resolve, reject) => {
                const opts = {
                    headers: {
                        'User-Agent': 'cgp-auto-patcher',
                        'Accept': 'application/vnd.github+json'
                    },
                    timeout: 10000
                };
                https.get(url, opts, (res) => {
                    if ((res.statusCode === 301 || res.statusCode === 302) && res.headers.location && redirects > 0) {
                        resolve(httpsGet(res.headers.location, redirects - 1));
                        return;
                    }
                    if (res.statusCode < 200 || res.statusCode >= 300) {
                        reject(new Error(`HTTP ${res.statusCode}`));
                        return;
                    }
                    const chunks = [];
                    res.on('data', c => chunks.push(c));
                    res.on('end', () => resolve(Buffer.concat(chunks)));
                    res.on('error', reject);
                }).on('error', reject);
            });
        }

        function which(cmd) {
            return new Promise((resolve) => {
                const shell = process.platform === 'win32' ? 'where' : 'which';
                exec(`${shell} ${cmd}`, { timeout: 5000 }, (err, stdout) => {
                    if (err || !stdout) { resolve(null); return; }
                    const first = stdout.toString().trim().split(/\\r?\\n/)[0];
                    resolve(first || null);
                });
            });
        }

        function selectAsset(plat, arch) {
            const map = {
                'linux-x64':    'cgp-linux-x86_64.tar.gz',
                'linux-arm64':  'cgp-linux-arm64.tar.gz',
                'darwin-x64':   'cgp-macos-x86_64.tar.gz',
                'darwin-arm64': 'cgp-macos-arm64.tar.gz',
                'win32-x64':    'cgp-windows-x86_64.zip',
            };
            return map[`${plat}-${arch}`] || null;
        }

        function execPromise(cmd, opts) {
            return new Promise((resolve, reject) => {
                exec(cmd, opts || {}, (err, stdout, stderr) => {
                    if (err) reject(err);
                    else resolve(stdout);
                });
            });
        }

        module.exports = { activate, deactivate: () => {} };
    """)


def install(
    target: str = "gui",
    *,
    extensions_root: Optional[Path] = None,
) -> str:
    """Install the auto-patcher extension. Returns a status message."""
    root = extensions_root or _extensions_root(target)
    version = __version__

    ext_dir = root / _ext_dir_name(version)

    # Clean up older versions
    for old in _find_existing(root):
        if old != ext_dir:
            shutil.rmtree(old, ignore_errors=True)

    # Create extension directory
    ext_dir.mkdir(parents=True, exist_ok=True)

    # Write package.json
    (ext_dir / "package.json").write_text(_generate_package_json(version), encoding="utf-8")

    # Write extension.js
    (ext_dir / "extension.js").write_text(_generate_extension_js(), encoding="utf-8")

    return f"Installed {EXTENSION_NAME} v{version} to {ext_dir}"


def uninstall(
    target: str = "gui",
    *,
    extensions_root: Optional[Path] = None,
) -> str:
    """Uninstall the auto-patcher extension. Returns a status message."""
    root = extensions_root or _extensions_root(target)

    existing = _find_existing(root)
    if not existing:
        return f"{EXTENSION_NAME} is not installed ({target})"

    for d in existing:
        shutil.rmtree(d, ignore_errors=True)

    return f"Uninstalled {EXTENSION_NAME} from {root}"


def status(
    target: str = "gui",
    *,
    extensions_root: Optional[Path] = None,
) -> str:
    """Check extension installation status. Returns a status message."""
    root = extensions_root or _extensions_root(target)

    existing = _find_existing(root)
    if not existing:
        return f"{EXTENSION_NAME}: not installed ({target})"

    versions = []
    for d in existing:
        # Extract version from directory name
        name = d.name
        ver = name[len(EXTENSION_NAME) + 1:]  # strip "cgp-auto-patcher-"
        versions.append(ver)

    installed_str = ", ".join(versions)
    return f"{EXTENSION_NAME}: installed v{installed_str} ({target}) at {root}"
