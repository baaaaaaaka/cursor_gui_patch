"""Manage the CGP auto-patcher VS Code workspace extension."""

from __future__ import annotations

import glob
import json
import os
import shutil
import sys
import textwrap
import time
from pathlib import Path
from typing import Optional

from . import __version__
from .discovery import _is_wsl, _ordered_wsl_user_dirs, _wsl_user_dirs

EXTENSION_NAME = "cgp-auto-patcher"
EXTENSION_ID = f"cgp.{EXTENSION_NAME}"
GITHUB_REPO = "baaaaaaaka/cursor_gui_patch"


def _wsl_gui_extensions_root() -> Optional[Path]:
    """Find the Windows Cursor extensions directory from within WSL."""
    users_dir = Path("/mnt/c/Users")
    if not users_dir.is_dir():
        return None

    for user_dir in _ordered_wsl_user_dirs(_wsl_user_dirs(users_dir)):
        ext_dir = user_dir / ".cursor" / "extensions"
        if ext_dir.is_dir():
            return ext_dir
    return None


def _extensions_root(target: str) -> Path:
    """Return the Cursor extensions root directory for *target* ('gui' or 'server')."""
    if target == "server":
        return Path.home() / ".cursor-server" / "extensions"
    # gui (default)
    if sys.platform == "darwin":
        return Path.home() / ".cursor" / "extensions"
    if sys.platform == "win32":
        return Path(os.environ.get("USERPROFILE", "~")) / ".cursor" / "extensions"
    # Linux — check for WSL (Windows Cursor reads from Windows filesystem)
    if _is_wsl():
        wsl_root = _wsl_gui_extensions_root()
        if wsl_root:
            return wsl_root
    return Path.home() / ".cursor" / "extensions"


def _ext_dir_name(version: str) -> str:
    return f"{EXTENSION_NAME}-{version}"


def _find_existing(extensions_root: Path) -> list[Path]:
    """Find all existing cgp-auto-patcher-* directories under *extensions_root*."""
    pattern = str(extensions_root / f"{EXTENSION_NAME}-*")
    return sorted(Path(p) for p in glob.glob(pattern) if Path(p).is_dir())


def _generate_package_json(version: str) -> str:
    return json.dumps(
        {
            "name": EXTENSION_NAME,
            "displayName": "CGP Auto Patcher",
            "description": "Auto re-apply cursor-gui-patch after Cursor updates",
            "version": version,
            "publisher": "cgp",
            "engines": {"vscode": "^1.80.0"},
            "extensionKind": ["workspace"],
            "activationEvents": ["onStartupFinished"],
            "main": "./extension.js",
        },
        indent=2,
    )


def _generate_extension_js() -> str:
    return textwrap.dedent("""\
        // CGP Auto Patcher – generated by cursor-gui-patch
        // This extension ensures cgp is available and runs `cgp patch` on activation.
        const vscode = require('vscode');
        const { execFile, exec } = require('child_process');
        const https = require('https');
        const fs = require('fs');
        const path = require('path');
        const os = require('os');
        const zlib = require('zlib');

        const REPO = '""" + GITHUB_REPO + """';

        // ── activate ──────────────────────────────────────
        async function activate(context) {
            try {
                const cgp = await ensureCgp();
                if (cgp) await runPatch(cgp);
            } catch (_) { /* never throw into Cursor */ }
        }

        // ── ensureCgp ─────────────────────────────────────
        async function ensureCgp() {
            // 1. Check PATH
            const found = await which('cgp');
            if (found) return found;

            // 2. Check well-known location
            const home = os.homedir();
            const knownBin = process.platform === 'win32'
                ? path.join(process.env.LOCALAPPDATA || path.join(home, 'AppData', 'Local'), 'cgp', 'cgp.exe')
                : path.join(home, '.local', 'bin', 'cgp');

            if (fs.existsSync(knownBin)) return knownBin;

            // 3. Download from GitHub
            return await downloadLatest();
        }

        // ── downloadLatest ────────────────────────────────
        async function downloadLatest() {
            const apiUrl = `https://api.github.com/repos/${REPO}/releases/latest`;
            const releaseJson = await httpsGet(apiUrl);
            const release = JSON.parse(releaseJson.toString('utf8'));
            const tag = release.tag_name;
            if (!tag) return null;

            const assetName = selectAsset(process.platform, process.arch);
            if (!assetName) return null;

            const downloadUrl = `https://github.com/${REPO}/releases/download/${tag}/${assetName}`;
            const data = await httpsGet(downloadUrl);

            const home = os.homedir();
            const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cgp-'));

            try {
                const archivePath = path.join(tmpDir, assetName);
                fs.writeFileSync(archivePath, data);

                // Extract
                if (assetName.endsWith('.tar.gz')) {
                    await execPromise(`tar xzf "${archivePath}"`, { cwd: tmpDir });
                } else if (assetName.endsWith('.zip')) {
                    if (process.platform === 'win32') {
                        await execPromise(
                            `powershell -NoProfile -Command "Expand-Archive -Path '${archivePath}' -DestinationPath '${tmpDir}' -Force"`,
                            { cwd: tmpDir }
                        );
                    } else {
                        await execPromise(`unzip -o "${archivePath}"`, { cwd: tmpDir });
                    }
                } else {
                    return null;
                }

                // Install to versioned directory
                const installRoot = process.platform === 'win32'
                    ? path.join(process.env.LOCALAPPDATA || path.join(home, 'AppData', 'Local'), 'cgp')
                    : path.join(home, '.local', 'lib', 'cgp');
                const binDir = process.platform === 'win32'
                    ? installRoot
                    : path.join(home, '.local', 'bin');
                const versionsDir = path.join(installRoot, 'versions');
                const versionDir = path.join(versionsDir, tag);

                fs.mkdirSync(versionsDir, { recursive: true });
                fs.mkdirSync(binDir, { recursive: true });

                // Remove old version dir if exists
                if (fs.existsSync(versionDir)) {
                    fs.rmSync(versionDir, { recursive: true, force: true });
                }

                // Move extracted cgp/ folder to version dir
                const extractedCgp = path.join(tmpDir, 'cgp');
                fs.renameSync(extractedCgp, versionDir);

                const exeName = process.platform === 'win32' ? 'cgp.exe' : 'cgp';
                const exePath = path.join(versionDir, exeName);

                // Make executable on Unix
                if (process.platform !== 'win32') {
                    try { fs.chmodSync(exePath, 0o755); } catch (_) {}
                }

                // Create current and bin links/copies.
                const currentLink = path.join(installRoot, 'current');
                const binLink = path.join(binDir, exeName);
                if (process.platform === 'win32') {
                    // Windows users often cannot create symlinks without admin/dev mode.
                    // Use copy fallback so installation is still usable.
                    try { fs.rmSync(currentLink, { recursive: true, force: true }); } catch (_) {}
                    try { fs.cpSync(versionDir, currentLink, { recursive: true }); } catch (_) {}
                    const currentExe = path.join(currentLink, exeName);
                    try { fs.copyFileSync(currentExe, binLink); } catch (_) {}
                    let binOk = false;
                    try { binOk = fs.existsSync(binLink) && fs.statSync(binLink).isFile(); } catch (_) {}
                    return binOk ? binLink : currentExe;
                }

                // Unix: prefer symlinks for fast upgrades.
                try { fs.unlinkSync(currentLink); } catch (_) {}
                try { fs.symlinkSync(versionDir, currentLink); } catch (_) {}
                try { fs.unlinkSync(binLink); } catch (_) {}
                try { fs.symlinkSync(exePath, binLink); } catch (_) {}
                return binLink;
            } finally {
                try { fs.rmSync(tmpDir, { recursive: true, force: true }); } catch (_) {}
            }
        }

        // ── runPatch ──────────────────────────────────────
        async function runPatch(cgpPath) {
            return new Promise((resolve) => {
                execFile(cgpPath, ['patch'], { timeout: 60000 }, (err, stdout, stderr) => {
                    if (err) { resolve(); return; }
                    const output = (stdout || '').toString();
                    const m = output.match(/Patched:\\s*(\\d+)/);
                    if (m && parseInt(m[1], 10) > 0) {
                        vscode.window.showInformationMessage(
                            `CGP: Patched ${m[1]} file(s). Reload to apply.`,
                            'Reload'
                        ).then(choice => {
                            if (choice === 'Reload') {
                                vscode.commands.executeCommand('workbench.action.reloadWindow');
                            }
                        });
                    }
                    resolve();
                });
            });
        }

        // ── helpers ───────────────────────────────────────
        function httpsGet(url, redirects) {
            if (redirects === undefined) redirects = 5;
            return new Promise((resolve, reject) => {
                const opts = {
                    headers: {
                        'User-Agent': 'cgp-auto-patcher',
                        'Accept': 'application/vnd.github+json'
                    },
                    timeout: 10000
                };
                https.get(url, opts, (res) => {
                    if ((res.statusCode === 301 || res.statusCode === 302) && res.headers.location && redirects > 0) {
                        resolve(httpsGet(res.headers.location, redirects - 1));
                        return;
                    }
                    if (res.statusCode < 200 || res.statusCode >= 300) {
                        reject(new Error(`HTTP ${res.statusCode}`));
                        return;
                    }
                    const chunks = [];
                    res.on('data', c => chunks.push(c));
                    res.on('end', () => resolve(Buffer.concat(chunks)));
                    res.on('error', reject);
                }).on('error', reject);
            });
        }

        function which(cmd) {
            return new Promise((resolve) => {
                const shell = process.platform === 'win32' ? 'where' : 'which';
                exec(`${shell} ${cmd}`, { timeout: 5000 }, (err, stdout) => {
                    if (err || !stdout) { resolve(null); return; }
                    const first = stdout.toString().trim().split(/\\r?\\n/)[0];
                    resolve(first || null);
                });
            });
        }

        function selectAsset(plat, arch) {
            const map = {
                'linux-x64':    'cgp-linux-x86_64.tar.gz',
                'linux-arm64':  'cgp-linux-arm64.tar.gz',
                'darwin-x64':   'cgp-macos-x86_64.tar.gz',
                'darwin-arm64': 'cgp-macos-arm64.tar.gz',
                'win32-x64':    'cgp-windows-x86_64.zip',
            };
            return map[`${plat}-${arch}`] || null;
        }

        function execPromise(cmd, opts) {
            return new Promise((resolve, reject) => {
                exec(cmd, opts || {}, (err, stdout, stderr) => {
                    if (err) reject(err);
                    else resolve(stdout);
                });
            });
        }

        module.exports = { activate, deactivate: () => {} };
    """)


def _to_vscode_uri_path(p: Path) -> str:
    """Convert a filesystem path to a VS Code file URI path component.

    Examples:
        /mnt/c/Users/x/.cursor/ext  → /c:/Users/x/.cursor/ext   (WSL)
        C:\\Users\\x\\.cursor\\ext   → /c:/Users/x/.cursor/ext   (Windows)
        /home/x/.cursor/ext          → /home/x/.cursor/ext       (Linux/macOS)
    """
    s = p.as_posix()
    # WSL: /mnt/c/... → /c:/...
    if s.startswith("/mnt/") and len(s) > 6 and s[6] == "/":
        drive = s[5]
        return f"/{drive}:{s[6:]}"
    # Native Windows: C:/... → /c:/...
    if len(s) >= 2 and s[1] == ":":
        return f"/{s[0].lower()}:{s[2:]}"
    return s


def _make_registry_entry(version: str, ext_dir: Path) -> dict:
    """Build an extensions.json entry for our extension."""
    return {
        "identifier": {"id": EXTENSION_ID},
        "version": version,
        "location": {
            "$mid": 1,
            "path": _to_vscode_uri_path(ext_dir),
            "scheme": "file",
        },
        "relativeLocation": _ext_dir_name(version),
        "metadata": {
            "isApplicationScoped": False,
            "isMachineScoped": False,
            "isBuiltin": False,
            "installedTimestamp": int(time.time() * 1000),
            "pinned": True,
            "source": "vsix",
        },
    }


def _read_extensions_json(extensions_root: Path) -> list:
    """Read and parse extensions.json, returning [] on any error."""
    json_path = extensions_root / "extensions.json"
    if not json_path.is_file():
        return []
    try:
        data = json.loads(json_path.read_text(encoding="utf-8"))
        return data if isinstance(data, list) else []
    except (json.JSONDecodeError, OSError):
        return []


def _write_extensions_json(extensions_root: Path, entries: list) -> None:
    """Write entries list to extensions.json."""
    json_path = extensions_root / "extensions.json"
    json_path.write_text(json.dumps(entries), encoding="utf-8")


def _register_extension(extensions_root: Path, version: str, ext_dir: Path) -> None:
    """Add or update the extension entry in extensions.json."""
    entries = _read_extensions_json(extensions_root)
    # Remove any existing cgp-auto-patcher entries
    entries = [
        e for e in entries
        if e.get("identifier", {}).get("id") != EXTENSION_ID
    ]
    entries.append(_make_registry_entry(version, ext_dir))
    _write_extensions_json(extensions_root, entries)


def _unregister_extension(extensions_root: Path) -> None:
    """Remove the extension entry from extensions.json."""
    entries = _read_extensions_json(extensions_root)
    if not entries:
        return
    new_entries = [
        e for e in entries
        if e.get("identifier", {}).get("id") != EXTENSION_ID
    ]
    if len(new_entries) != len(entries):
        _write_extensions_json(extensions_root, new_entries)


def install(
    target: str = "gui",
    *,
    extensions_root: Optional[Path] = None,
) -> str:
    """Install the auto-patcher extension. Returns a status message."""
    root = extensions_root or _extensions_root(target)
    version = __version__

    ext_dir = root / _ext_dir_name(version)

    # Clean up older versions (directories + registry entries)
    for old in _find_existing(root):
        if old != ext_dir:
            shutil.rmtree(old, ignore_errors=True)

    # Create extension directory
    ext_dir.mkdir(parents=True, exist_ok=True)

    # Write package.json
    (ext_dir / "package.json").write_text(_generate_package_json(version), encoding="utf-8")

    # Write extension.js
    (ext_dir / "extension.js").write_text(_generate_extension_js(), encoding="utf-8")

    # Register in extensions.json so Cursor discovers the extension
    _register_extension(root, version, ext_dir)

    return f"Installed {EXTENSION_NAME} v{version} to {ext_dir}"


def uninstall(
    target: str = "gui",
    *,
    extensions_root: Optional[Path] = None,
) -> str:
    """Uninstall the auto-patcher extension. Returns a status message."""
    root = extensions_root or _extensions_root(target)

    existing = _find_existing(root)
    if not existing:
        _unregister_extension(root)  # clean up orphan registry entries
        return f"{EXTENSION_NAME} is not installed ({target})"

    for d in existing:
        shutil.rmtree(d, ignore_errors=True)

    _unregister_extension(root)

    return f"Uninstalled {EXTENSION_NAME} from {root}"


def status(
    target: str = "gui",
    *,
    extensions_root: Optional[Path] = None,
) -> str:
    """Check extension installation status. Returns a status message."""
    root = extensions_root or _extensions_root(target)

    existing = _find_existing(root)
    if not existing:
        return f"{EXTENSION_NAME}: not installed ({target})"

    versions = []
    for d in existing:
        # Extract version from directory name
        name = d.name
        ver = name[len(EXTENSION_NAME) + 1:]  # strip "cgp-auto-patcher-"
        versions.append(ver)

    installed_str = ", ".join(versions)
    return f"{EXTENSION_NAME}: installed v{installed_str} ({target}) at {root}"
